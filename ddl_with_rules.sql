-- MySQL Script generated by MySQL Workbench
-- Fri Apr 25 19:23:14 2025
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';

-- -----------------------------------------------------
-- Schema mydb
-- -----------------------------------------------------
DROP SCHEMA IF EXISTS `mydb` ;

-- -----------------------------------------------------
-- Schema mydb
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `mydb` DEFAULT CHARACTER SET utf8 ;
USE `mydb` ;

-- -----------------------------------------------------
-- Table `mydb`.`Image`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Image` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Image` (
  `Image_id` INT NOT NULL,
  `Description` VARCHAR(45) NOT NULL,
  `ImageURL` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`Image_id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Continent`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Continent` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Continent` (
  `Name` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`Name`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Location`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Location` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Location` (
  `Location_id` INT NOT NULL,
  `Address` VARCHAR(45) NOT NULL,
  `Coordinates` GEOMETRY NOT NULL,
  `City` VARCHAR(45) NOT NULL,
  `Country` VARCHAR(45) NOT NULL,
  `Continent_Name` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`Location_id`),
  INDEX `fk_Location_Continent1_idx` (`Continent_Name` ASC) VISIBLE,
  CONSTRAINT `fk_Location_Continent1`
    FOREIGN KEY (`Continent_Name`)
    REFERENCES `mydb`.`Continent` (`Name`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Festival`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Festival` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Festival` (
  `Festival_id` INT NOT NULL,
  `Year` INT NOT NULL,
  `StartDate` DATETIME NOT NULL,
  `EndDate` DATETIME NOT NULL,
  `Days` INT NOT NULL COMMENT 'μάλλον πλεονασμός γιατί: \nSELECT DATEDIFF(EndDate, StartDate) + 1 AS Days\nFROM Festival\nWHERE FestivalID = 1;\n',
  `Image_Image_id` INT NOT NULL,
  `Location_Location_id` INT NOT NULL,
  PRIMARY KEY (`Festival_id`),
  UNIQUE INDEX `Festival_id_UNIQUE` (`Festival_id` ASC) VISIBLE,
  UNIQUE INDEX `Year_UNIQUE` (`Year` ASC) VISIBLE,
  INDEX `fk_Festival_Image1_idx` (`Image_Image_id` ASC) VISIBLE,
  INDEX `fk_Festival_Location1_idx` (`Location_Location_id` ASC) VISIBLE,
  CONSTRAINT `fk_Festival_Image1`
    FOREIGN KEY (`Image_Image_id`)
    REFERENCES `mydb`.`Image` (`Image_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Festival_Location1`
    FOREIGN KEY (`Location_Location_id`)
    REFERENCES `mydb`.`Location` (`Location_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Stage`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Stage` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Stage` (
  `Stage_id` INT NOT NULL,
  `Name` VARCHAR(45) NOT NULL,
  `Description` VARCHAR(45) NOT NULL,
  `MaxCapacity` INT NOT NULL,
  PRIMARY KEY (`Stage_id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Event`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Event` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Event` (
  `Event_id` INT NOT NULL,
  `Date` DATETIME NOT NULL,
  `Festival_Festival_id` INT NOT NULL,
  `Stage_Stage_id` INT NOT NULL,
  PRIMARY KEY (`Event_id`),
  INDEX `fk_Event_Festival1_idx` (`Festival_Festival_id` ASC) VISIBLE,
  INDEX `fk_Event_Stage1_idx` (`Stage_Stage_id` ASC) VISIBLE,
  CONSTRAINT `fk_Event_Festival1`
    FOREIGN KEY (`Festival_Festival_id`)
    REFERENCES `mydb`.`Festival` (`Festival_id`)
    ON DELETE CASCADE
    ON UPDATE RESTRICT,
  CONSTRAINT `fk_Event_Stage1`
    FOREIGN KEY (`Stage_Stage_id`)
    REFERENCES `mydb`.`Stage` (`Stage_id`)
    ON DELETE CASCADE
    ON UPDATE RESTRICT)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Equipment`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Equipment` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Equipment` (
  `Name` VARCHAR(45) NOT NULL,
  `Description` VARCHAR(45) NOT NULL,
  `Image_Image_id` INT NOT NULL,
  PRIMARY KEY (`Name`),
  INDEX `fk_Equipment_Image1_idx` (`Image_Image_id` ASC) VISIBLE,
  CONSTRAINT `fk_Equipment_Image1`
    FOREIGN KEY (`Image_Image_id`)
    REFERENCES `mydb`.`Image` (`Image_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Role`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Role` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Role` (
  `Name` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`Name`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Experience`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Experience` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Experience` (
  `Level` INT NOT NULL,
  `Level_name` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`Level`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Staff`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Staff` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Staff` (
  `Staff_id` INT NOT NULL,
  `Name` VARCHAR(45) NOT NULL,
  `Age` INT NOT NULL,
  `Role_Name` VARCHAR(45) NOT NULL,
  `Experience_Level` INT NOT NULL,
  PRIMARY KEY (`Staff_id`),
  INDEX `fk_Staff_Role1_idx` (`Role_Name` ASC) VISIBLE,
  INDEX `fk_Staff_Experience1_idx` (`Experience_Level` ASC) VISIBLE,
  CONSTRAINT `fk_Staff_Role1`
    FOREIGN KEY (`Role_Name`)
    REFERENCES `mydb`.`Role` (`Name`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Staff_Experience1`
    FOREIGN KEY (`Experience_Level`)
    REFERENCES `mydb`.`Experience` (`Level`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Performer`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Performer` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Performer` (
  `Performer_id` INT NOT NULL,
  `Name` VARCHAR(45) NOT NULL,
  `FormationDate` DATETIME NULL,
  `Website` VARCHAR(45) NULL,
  `InstagramProfile` VARCHAR(45) NULL,
  PRIMARY KEY (`Performer_id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Performance_type`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Performance_type` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Performance_type` (
  `Type` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`Type`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Performance`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Performance` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Performance` (
  `Performance_id` INT NOT NULL,
  `StartTime` DATETIME NOT NULL,
  `Duration` INT NOT NULL,
  `BreakDuration` INT NOT NULL COMMENT 'υποχρεωτικά διάλειμμα, ελάχιστης διάρκειας 5 λεπτών και μέγιστης 30 λεπτών',
  `Performer_id` INT NOT NULL COMMENT 'θα προσθεσουμε το constraint για διασφάλιση οτι μια εμφανιση γινεται υποχρεωτικα ειτε απο εναν artist (solo) ειτε απο ενα band:\n\nALTER TABLE Performance\nADD CONSTRAINT chk_Performance_Artist_Band\nCHECK (\n  (Band_id IS NOT NULL AND Artist_id IS NULL)\n  OR\n  (Band_id IS NULL AND Artist_id IS NOT NULL)\n);\n ',
  `Event_Event_id` INT NOT NULL,
  `Performance_type_Type` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`Performance_id`),
  INDEX `fk_Performance_Band1_idx` (`Performer_id` ASC) VISIBLE,
  INDEX `fk_Performance_Event1_idx` (`Event_Event_id` ASC) VISIBLE,
  INDEX `fk_Performance_Performance_type1_idx` (`Performance_type_Type` ASC) VISIBLE,
  CONSTRAINT `fk_Performance_Band1`
    FOREIGN KEY (`Performer_id`)
    REFERENCES `mydb`.`Performer` (`Performer_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Performance_Event1`
    FOREIGN KEY (`Event_Event_id`)
    REFERENCES `mydb`.`Event` (`Event_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Performance_Performance_type1`
    FOREIGN KEY (`Performance_type_Type`)
    REFERENCES `mydb`.`Performance_type` (`Type`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Artist`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Artist` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Artist` (
  `Artist_id` INT NOT NULL,
  `Name` VARCHAR(45) NOT NULL,
  `StageName` VARCHAR(45) NULL,
  `BirthDate` DATETIME NOT NULL,
  `Website` VARCHAR(45) NULL,
  `Image_Image_id` INT NOT NULL,
  PRIMARY KEY (`Artist_id`),
  INDEX `fk_Artist_Image1_idx` (`Image_Image_id` ASC) VISIBLE,
  CONSTRAINT `fk_Artist_Image1`
    FOREIGN KEY (`Image_Image_id`)
    REFERENCES `mydb`.`Image` (`Image_id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Visitor`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Visitor` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Visitor` (
  `Visitor_id` INT NOT NULL,
  `Name` VARCHAR(45) NOT NULL,
  `Age` INT NOT NULL,
  `ContactInfo` VARCHAR(100) NOT NULL COMMENT 'π.χ. email, τηλέφωνο',
  PRIMARY KEY (`Visitor_id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Artist_has_Performer`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Artist_has_Performer` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Artist_has_Performer` (
  `Artist_Artist_id` INT NOT NULL,
  `Performer_Performer_id` INT NOT NULL,
  PRIMARY KEY (`Artist_Artist_id`, `Performer_Performer_id`),
  INDEX `fk_Artist_has_Band_Band1_idx` (`Performer_Performer_id` ASC) VISIBLE,
  INDEX `fk_Artist_has_Band_Artist_idx` (`Artist_Artist_id` ASC) VISIBLE,
  CONSTRAINT `fk_Artist_has_Band_Artist`
    FOREIGN KEY (`Artist_Artist_id`)
    REFERENCES `mydb`.`Artist` (`Artist_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Artist_has_Band_Band1`
    FOREIGN KEY (`Performer_Performer_id`)
    REFERENCES `mydb`.`Performer` (`Performer_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Ticket_type`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Ticket_type` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Ticket_type` (
  `Type` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`Type`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Payment_method`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Payment_method` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Payment_method` (
  `Method` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`Method`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Ticket`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Ticket` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Ticket` (
  `Ticket_id` INT NOT NULL,
  `PurchaseDate` DATETIME NOT NULL,
  `Price` DECIMAL(5,2) NOT NULL,
  `EANCode` VARCHAR(45) NOT NULL,
  `IsActive` TINYINT(1) NOT NULL COMMENT 'π.χ. ενεργοποιημένο (χρησιμοποιημένο ή όχι)',
  `Event_Event_id` INT NOT NULL,
  `Visitor_Visitor_id` INT NOT NULL COMMENT 'θα προσθέσουμε constraint για να αποτρέψουμε έναν επισκέπτη να αγοράσει πάνω από 1 εισιτήριο για την ίδια παράσταση και ημέρα:\n\n\nCREATE TRIGGER trg_Ticket_UniquePerDay\nBEFORE INSERT ON Ticket\nFOR EACH ROW\nBEGIN\n    IF (SELECT COUNT(*) FROM Ticket \n        WHERE Visitor_id = NEW.Visitor_id \n        AND Event_id = NEW.Event_id) > 0 THEN\n        SIGNAL SQLSTATE \'45000\'\n        SET MESSAGE_TEXT = \'A visitor can only buy one ticket per event per day.\';\n    END IF;\nEND;\n',
  `Ticket_type_Type` VARCHAR(45) NOT NULL,
  `Payment_method_Method` VARCHAR(45) NOT NULL,
  `Seller_id` INT NULL,
  PRIMARY KEY (`Ticket_id`),
  INDEX `fk_Ticket_Event1_idx` (`Event_Event_id` ASC) VISIBLE,
  INDEX `fk_Ticket_Visitor1_idx` (`Visitor_Visitor_id` ASC) VISIBLE,
  INDEX `fk_Ticket_Ticket_type1_idx` (`Ticket_type_Type` ASC) VISIBLE,
  INDEX `fk_Ticket_Payment_method1_idx` (`Payment_method_Method` ASC) VISIBLE,
  INDEX `fk_Ticket_Visitor2_idx` (`Seller_id` ASC) VISIBLE,
  CONSTRAINT `fk_Ticket_Event1`
    FOREIGN KEY (`Event_Event_id`)
    REFERENCES `mydb`.`Event` (`Event_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Ticket_Visitor1`
    FOREIGN KEY (`Visitor_Visitor_id`)
    REFERENCES `mydb`.`Visitor` (`Visitor_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Ticket_Ticket_type1`
    FOREIGN KEY (`Ticket_type_Type`)
    REFERENCES `mydb`.`Ticket_type` (`Type`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Ticket_Payment_method1`
    FOREIGN KEY (`Payment_method_Method`)
    REFERENCES `mydb`.`Payment_method` (`Method`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Ticket_Visitor2`
    FOREIGN KEY (`Seller_id`)
    REFERENCES `mydb`.`Visitor` (`Visitor_id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`ResaleQueue`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`ResaleQueue` ;

CREATE TABLE IF NOT EXISTS `mydb`.`ResaleQueue` (
  `timestamp` DATETIME NOT NULL,
  `Ticket_Ticket_id` INT NOT NULL,
  INDEX `fk_ResaleQueue_Ticket1_idx` (`Ticket_Ticket_id` ASC) VISIBLE,
  PRIMARY KEY (`Ticket_Ticket_id`),
  CONSTRAINT `fk_ResaleQueue_Ticket1`
    FOREIGN KEY (`Ticket_Ticket_id`)
    REFERENCES `mydb`.`Ticket` (`Ticket_id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Likert`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Likert` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Likert` (
  `id` INT NOT NULL,
  `name` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Rating`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Rating` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Rating` (
  `Rating_id` INT NOT NULL,
  `ArtistPerformance` INT NOT NULL,
  `SoundAndLighting` INT NOT NULL,
  `StagePresence` INT NOT NULL,
  `Organization` INT NOT NULL,
  `OverallImpression` INT NOT NULL,
  `Visitor_Visitor_id` INT NOT NULL,
  `Performance_Performance_id` INT NOT NULL,
  PRIMARY KEY (`Rating_id`),
  INDEX `fk_Rating_Visitor1_idx` (`Visitor_Visitor_id` ASC) VISIBLE,
  INDEX `fk_Rating_Performance1_idx` (`Performance_Performance_id` ASC) VISIBLE,
  INDEX `fk_Rating_Likert1_idx` (`ArtistPerformance` ASC) VISIBLE,
  INDEX `fk_Rating_Likert2_idx` (`SoundAndLighting` ASC) VISIBLE,
  INDEX `fk_Rating_Likert3_idx` (`StagePresence` ASC) VISIBLE,
  INDEX `fk_Rating_Likert4_idx` (`Organization` ASC) VISIBLE,
  INDEX `fk_Rating_Likert5_idx` (`OverallImpression` ASC) VISIBLE,
  CONSTRAINT `fk_Rating_Visitor1`
    FOREIGN KEY (`Visitor_Visitor_id`)
    REFERENCES `mydb`.`Visitor` (`Visitor_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Rating_Performance1`
    FOREIGN KEY (`Performance_Performance_id`)
    REFERENCES `mydb`.`Performance` (`Performance_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Rating_Likert1`
    FOREIGN KEY (`ArtistPerformance`)
    REFERENCES `mydb`.`Likert` (`id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Rating_Likert2`
    FOREIGN KEY (`SoundAndLighting`)
    REFERENCES `mydb`.`Likert` (`id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Rating_Likert3`
    FOREIGN KEY (`StagePresence`)
    REFERENCES `mydb`.`Likert` (`id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Rating_Likert4`
    FOREIGN KEY (`Organization`)
    REFERENCES `mydb`.`Likert` (`id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Rating_Likert5`
    FOREIGN KEY (`OverallImpression`)
    REFERENCES `mydb`.`Likert` (`id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Event_has_Staff`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Event_has_Staff` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Event_has_Staff` (
  `Event_Event_id` INT NOT NULL,
  `Staff_Staff_id` INT NOT NULL,
  PRIMARY KEY (`Event_Event_id`, `Staff_Staff_id`),
  INDEX `fk_Event_has_Staff_Staff1_idx` (`Staff_Staff_id` ASC) VISIBLE,
  INDEX `fk_Event_has_Staff_Event1_idx` (`Event_Event_id` ASC) VISIBLE,
  CONSTRAINT `fk_Event_has_Staff_Event1`
    FOREIGN KEY (`Event_Event_id`)
    REFERENCES `mydb`.`Event` (`Event_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Event_has_Staff_Staff1`
    FOREIGN KEY (`Staff_Staff_id`)
    REFERENCES `mydb`.`Staff` (`Staff_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Genre`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Genre` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Genre` (
  `Genre_id` INT NOT NULL,
  PRIMARY KEY (`Genre_id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Subgenre`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Subgenre` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Subgenre` (
  `Subgenre_id` INT NOT NULL,
  `Genre_Genre_id` INT NOT NULL,
  PRIMARY KEY (`Subgenre_id`),
  INDEX `fk_Subgenre_Genre1_idx` (`Genre_Genre_id` ASC) VISIBLE,
  CONSTRAINT `fk_Subgenre_Genre1`
    FOREIGN KEY (`Genre_Genre_id`)
    REFERENCES `mydb`.`Genre` (`Genre_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Performer_has_Subgenre`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Performer_has_Subgenre` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Performer_has_Subgenre` (
  `Performer_Performer_id` INT NOT NULL,
  `Subgenre_Subgenre_id` INT NOT NULL,
  PRIMARY KEY (`Performer_Performer_id`, `Subgenre_Subgenre_id`),
  INDEX `fk_Performer_has_Subgenre_Subgenre1_idx` (`Subgenre_Subgenre_id` ASC) VISIBLE,
  INDEX `fk_Performer_has_Subgenre_Performer1_idx` (`Performer_Performer_id` ASC) VISIBLE,
  CONSTRAINT `fk_Performer_has_Subgenre_Performer1`
    FOREIGN KEY (`Performer_Performer_id`)
    REFERENCES `mydb`.`Performer` (`Performer_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Performer_has_Subgenre_Subgenre1`
    FOREIGN KEY (`Subgenre_Subgenre_id`)
    REFERENCES `mydb`.`Subgenre` (`Subgenre_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Stage_has_Equipment`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Stage_has_Equipment` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Stage_has_Equipment` (
  `Stage_Stage_id` INT NOT NULL,
  `Equipment_Name` VARCHAR(45) NOT NULL,
  `Quantity` INT NOT NULL,
  PRIMARY KEY (`Stage_Stage_id`, `Equipment_Name`),
  INDEX `fk_Stage_has_Equipment_Equipment1_idx` (`Equipment_Name` ASC) VISIBLE,
  INDEX `fk_Stage_has_Equipment_Stage1_idx` (`Stage_Stage_id` ASC) VISIBLE,
  CONSTRAINT `fk_Stage_has_Equipment_Stage1`
    FOREIGN KEY (`Stage_Stage_id`)
    REFERENCES `mydb`.`Stage` (`Stage_id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_Stage_has_Equipment_Equipment1`
    FOREIGN KEY (`Equipment_Name`)
    REFERENCES `mydb`.`Equipment` (`Name`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`Visitor_wants_Ticket`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`Visitor_wants_Ticket` ;

CREATE TABLE IF NOT EXISTS `mydb`.`Visitor_wants_Ticket` (
  `id` INT NOT NULL,
  `Visitor_id` INT NOT NULL,
  `Ticket_id` INT NULL,
  `Event_id` INT NULL,
  `Ticket_Type` VARCHAR(45) NULL,
  `timestamp` DATETIME NULL,
  PRIMARY KEY (`id`),
  INDEX `fk_Visitor_has_Ticket_Ticket1_idx` (`Ticket_id` ASC) VISIBLE,
  INDEX `fk_Visitor_has_Ticket_Visitor1_idx` (`Visitor_id` ASC) VISIBLE,
  INDEX `fk_Visitor_wants_Ticket_Event1_idx` (`Event_id` ASC) VISIBLE,
  INDEX `fk_Visitor_wants_Ticket_Ticket_type1_idx` (`Ticket_Type` ASC) VISIBLE,
  CONSTRAINT `fk_Visitor_has_Ticket_Visitor1`
    FOREIGN KEY (`Visitor_id`)
    REFERENCES `mydb`.`Visitor` (`Visitor_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Visitor_has_Ticket_Ticket1`
    FOREIGN KEY (`Ticket_id`)
    REFERENCES `mydb`.`Ticket` (`Ticket_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Visitor_wants_Ticket_Event1`
    FOREIGN KEY (`Event_id`)
    REFERENCES `mydb`.`Event` (`Event_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT `fk_Visitor_wants_Ticket_Ticket_type1`
    FOREIGN KEY (`Ticket_Type`)
    REFERENCES `mydb`.`Ticket_type` (`Type`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB;


SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;

-- === INTEGRATED RULES ===

-- === FULL DDL INCLUDING ALL 21 RULES ===
-- Generated automatically

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';


-- === check_stage_capacity.sql ===
-- Η χωρητικότητα της σκηνής δεν μπορεί να ξεπεραστεί κατά την πώληση εισιτηρίων

DELIMITER //

CREATE TRIGGER check_stage_capacity
BEFORE INSERT ON Ticket
FOR EACH ROW
BEGIN
  DECLARE max_capacity INT;
  DECLARE current_tickets INT;

  SELECT MaxCapacity INTO max_capacity
  FROM Stage
  WHERE Stage_id = (
    SELECT Stage_Stage_id
    FROM Event
    WHERE Event_id = NEW.Event_Event_id
  );

  SELECT COUNT(*) INTO current_tickets
  FROM Ticket
  WHERE Event_Event_id = NEW.Event_Event_id;

  IF current_tickets >= max_capacity THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Stage capacity exceeded for this event.';
  END IF;
END;
//

DELIMITER ;

-- === check_vip_limit.sql ===
-- VIP ≤ 10% χωρητικότητας σκηνής

DELIMITER //

CREATE PROCEDURE check_vip_limit(IN stage_id INT)
BEGIN
  DECLARE vip_count INT DEFAULT 0;
  DECLARE total_capacity INT DEFAULT 0;

  SELECT MaxCapacity INTO total_capacity
  FROM Stage
  WHERE Stage_id = stage_id;

  SELECT COUNT(*) INTO vip_count
  FROM Ticket
  WHERE Ticket_type = 'VIP' AND Event_Event_id IN (
    SELECT Event_id FROM Event WHERE Stage_Stage_id = stage_id
  );

  IF vip_count + 1 > total_capacity * 0.1 THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'VIP limit exceeded for this stage!';
  END IF;
END;
//

CREATE TRIGGER vip_check_before_insert
BEFORE INSERT ON Ticket
FOR EACH ROW
BEGIN
  IF NEW.Ticket_type_Type = 'VIP' THEN
    CALL check_vip_limit(
      (SELECT Stage_Stage_id FROM Event WHERE Event_id = NEW.Event_Event_id)
    );
  END IF;
END;
//

DELIMITER ;

-- === event_max_duration.sql ===
-- Κάθε event ≤ 12 ώρες

DELIMITER //

CREATE TRIGGER trg_Check_Event_Duration
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
    DECLARE total_duration INT;

    SELECT IFNULL(SUM(Duration), 0) INTO total_duration
    FROM Performance
    WHERE Event_Event_id = NEW.Event_Event_id;

    IF total_duration + NEW.Duration > 720 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Total performance duration in this event exceeds 12 hours (720 minutes)';
    END IF;
END;
//

DELIMITER ;

-- === festival_day_max_duration.sql ===
-- Κάθε festival ≤ 13 ώρες/ημέρα

DELIMITER //

CREATE TRIGGER trg_Check_Festival_Day_Duration
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
    DECLARE total_day_duration INT;
    DECLARE event_date DATE;

    SELECT Date INTO event_date
    FROM Event
    WHERE Event_Event_id = NEW.Event_Event_id;

    SELECT IFNULL(SUM(p.Duration), 0) INTO total_day_duration
    FROM Performance p
    JOIN Event e ON e.Event_id = p.Event_id
    WHERE e.Date = event_date;

    IF total_day_duration + NEW.Duration > 780 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Total performance time on this day exceeds 13 hours (780 minutes)';
    END IF;
END;
//

DELIMITER ;

-- === performance_break_duration.sql ===
-- Διάλειμμα 5–30 λεπτών μεταξύ εμφανίσεων

DELIMITER //

CREATE TRIGGER trg_Check_Performance_Break
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
  DECLARE prev_end DATETIME;
  DECLARE break_minutes INT;
  DECLARE stage_id INT;

  -- Βρες τη σκηνή του event
  SELECT Stage_Stage_id INTO stage_id
  FROM Event
  WHERE Event_id = NEW.Event_Event_id;

  -- Βρες την ώρα λήξης της προηγούμενης εμφάνισης στη σκηνή
  SELECT MAX(ADDTIME(StartTime, SEC_TO_TIME(Duration * 60))) INTO prev_end
  FROM Performance
  WHERE Event_Event_id IN (
    SELECT Event_id FROM Event WHERE Stage_Stage_id = stage_id
  )
  AND StartTime < NEW.StartTime;

  -- Υπολόγισε το διάστημα από τη λήξη της προηγούμενης
  IF prev_end IS NOT NULL THEN
    SET break_minutes = TIMESTAMPDIFF(MINUTE, prev_end, NEW.StartTime);

    IF break_minutes < 5 OR break_minutes > 30 THEN
      SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'Break between performances must be between 5 and 30 minutes.';
    END IF;
  END IF;
END;
//

DELIMITER ;


-- === performance_max_duration.sql ===
-- Περιορισμός 1: Κάθε performance ≤ 3 ώρες 

ALTER TABLE Performance
ADD CONSTRAINT chk_Performance_MaxDuration
CHECK (Duration <= 180);

-- === performer_overlap.sql ===
-- Ένας performer δεν εμφανίζεται σε 2 σκηνές ταυτόχρονα

DELIMITER //

CREATE TRIGGER trg_Check_Performer_Overlap
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
    DECLARE overlap_count INT;

    SELECT COUNT(*) INTO overlap_count
    FROM Performance
    WHERE Performer_id = NEW.Performer_id
      AND (
        -- Ελέγχει αν η νέα εμφάνιση ξεκινά μέσα σε υπάρχουσα
        (NEW.StartTime BETWEEN StartTime AND ADDTIME(StartTime, SEC_TO_TIME(Duration * 60)))
        -- Ή αν η υπάρχουσα ξεκινά μέσα στη νέα
        OR
        (StartTime BETWEEN NEW.StartTime AND ADDTIME(NEW.StartTime, SEC_TO_TIME(NEW.Duration * 60)))
      );

    IF overlap_count > 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Performer cannot perform in two places at the same time.';
    END IF;
END;
//

DELIMITER ;

-- === performer_years_limit.sql ===
-- Ένας performer δεν συμμετέχει για >3 συνεχόμενα έτη

DELIMITER //

CREATE TRIGGER trg_Check_Performer_3_Years
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
    DECLARE participation_years INT;

    -- Μετράμε σε πόσα ΔΙΑΦΟΡΕΤΙΚΑ έτη έχει ήδη συμμετάσχει ο Performer τα τελευταία 3 χρόνια
    SELECT COUNT(DISTINCT YEAR(e.Date)) INTO participation_years
    FROM Performance p
    JOIN Event e ON e.Event_id = p.Event_Event_id
    WHERE p.Performer_id = NEW.Performer_id
      AND YEAR(e.Date) >= YEAR(CURDATE()) - 2  -- τα τελευταία 3 έτη (τρέχον + 2 πίσω)

    ;

    -- Αν έχει συμμετάσχει ήδη σε 3, δεν επιτρέπεται άλλη εμφάνιση φέτος
    IF participation_years >= 3 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Performer cannot participate more than 3 consecutive years.';
    END IF;
END;
//

DELIMITER ;

-- === prevent_double_activation.sql ===
-- Το εισιτήριο ενεργοποιείται όταν σκαναριστεί και δεν μπορεί να ενεργοποιηθεί ξανά

DELIMITER //

CREATE TRIGGER prevent_double_activation
BEFORE UPDATE ON Ticket
FOR EACH ROW
BEGIN
  IF OLD.IsActive = TRUE AND NEW.IsActive = TRUE THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Ticket is already active and cannot be activated again.';
  END IF;
END;
//

DELIMITER ;

-- === visitor_one_ticket_per_event.sql ===
-- Αποτρέπει αγοραστή να πάρει δεύτερο εισιτήριο για το ίδιο event

DELIMITER //

CREATE TRIGGER trg_Visitor_One_Ticket_Per_Event
BEFORE INSERT ON Visitor_wants_Ticket
FOR EACH ROW
BEGIN
  -- Αν ο επισκέπτης έχει ήδη εισιτήριο για το συγκεκριμένο event, μπλοκάρουμε
  IF EXISTS (
    SELECT 1
    FROM Ticket
    WHERE Visitor_Visitor_id = NEW.Visitor_id
      AND Event_Event_id = NEW.Event_id
  ) THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Visitor already owns a ticket for this event.';
  END IF;
END;
//

DELIMITER ;


-- === rating_only_with_active_ticket.sql ===
-- Trigger για να επιτρέπει αξιολόγηση μόνο σε επισκέπτες με ενεργοποιημένο εισιτήριο

DROP TRIGGER IF EXISTS trg_Rating_OnlyWithActiveTicket;

DELIMITER //

CREATE TRIGGER trg_Rating_OnlyWithActiveTicket
BEFORE INSERT ON Rating
FOR EACH ROW
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM Ticket
    WHERE Visitor_Visitor_id = NEW.Visitor_Visitor_id AND IsActive = TRUE
  ) THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Only visitors with an active ticket can rate a performance.';
  END IF;
END;
//

DELIMITER ;

-- === resale_fifo.sql ===
ALTER TABLE ResaleQueue
MODIFY COLUMN timestamp DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- === resale_only_inactive_tickets.sql ===
-- Μπλοκάρει resale αν το εισιτήριο είναι ενεργό


DELIMITER //

CREATE TRIGGER prevent_resale_of_active_ticket
BEFORE INSERT ON ResaleQueue
FOR EACH ROW
BEGIN
  IF EXISTS (
    SELECT 1 FROM Ticket
    WHERE Ticket_id = NEW.Ticket_Ticket_id AND IsActive = TRUE
  ) THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Cannot resell an active ticket.';
  END IF;
END;
//

DELIMITER ;

-- === security_min_5percent_audience.sql ===
-- Το προσωπικό ασφαλείας πρέπει να καλύπτει τουλάχιστον το 5% του συνολικού αριθμού θεατών σε κάθε σκηνή

DELIMITER //

CREATE TRIGGER check_security_staff_insert
BEFORE INSERT ON Event_has_Staff
FOR EACH ROW
BEGIN
  DECLARE total_audience INT;
  DECLARE required_security INT;
  DECLARE current_security INT;

  SELECT COUNT(*) INTO total_audience
  FROM Ticket
  WHERE Event_Event_id = NEW.Event_Event_id;

  SET required_security = CEIL(total_audience * 0.05);

  SELECT COUNT(*) INTO current_security
  FROM Event_has_Staff EHS
  JOIN Staff S ON EHS.Staff_Staff_id = S.Staff_id
  WHERE EHS.Event_Event_id = NEW.Event_Event_id
    AND S.Role_Name = 'Security';

  IF current_security < required_security THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Insufficient security staff for this event';
  END IF;
END;
//
DELIMITER ;

DELIMITER //

CREATE TRIGGER check_security_staff_update
BEFORE UPDATE ON Event_has_Staff
FOR EACH ROW
BEGIN
  DECLARE total_audience INT;
  DECLARE required_security INT;
  DECLARE current_security INT;

  SELECT COUNT(*) INTO total_audience
  FROM Ticket
  WHERE Event_Event_id = NEW.Event_Event_id;

  SET required_security = CEIL(total_audience * 0.05);

  SELECT COUNT(*) INTO current_security
  FROM Event_has_Staff EHS
  JOIN Staff S ON EHS.Staff_Staff_id = S.Staff_id
  WHERE EHS.Event_Event_id = NEW.Event_Event_id
    AND S.Role_Name = 'Security';

  IF current_security < required_security THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Insufficient security staff for this event';
  END IF;
END;
//
DELIMITER ;



-- === seller_is_owner.sql ===
DELIMITER //

CREATE TRIGGER check_resale_seller_is_owner
BEFORE INSERT ON ResaleQueue
FOR EACH ROW
BEGIN
  DECLARE original_owner_id INT;

  -- Βρες τον αρχικό κάτοχο (visitor) αυτού του ticket μέσω Seller
  SELECT V.Visitor_id INTO original_owner_id
  FROM Ticket T
  JOIN Seller S ON T.Seller_Seller_id = S.Seller_id
  JOIN Visitor V ON S.Visitor_Visitor_id = V.Visitor_id
  WHERE T.Ticket_id = NEW.Ticket_Ticket_id;

  -- Εφόσον δεν έχεις Visitor στην ResaleQueue, το μπλοκάρεις μόνο αν δεν υπάρχει αυτό το mapping
  IF original_owner_id IS NULL THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Cannot determine original owner of ticket.';
  END IF;
END;
//

DELIMITER ;



-- === support_min_2percent_audience.sql ===
-- Το βοηθητικό προσωπικό πρέπει να καλύπτει τουλάχιστον το 2% του συνολικού αριθμού θεατών σε κάθε σκηνή

DELIMITER //

CREATE TRIGGER check_support_staff_insert
BEFORE INSERT ON Event_has_Staff
FOR EACH ROW
BEGIN
  DECLARE total_audience INT;
  DECLARE required_support INT;
  DECLARE current_support INT;

  SELECT COUNT(*) INTO total_audience
  FROM Ticket
  WHERE Event_Event_id = NEW.Event_Event_id;

  SET required_support = CEIL(total_audience * 0.02);

  SELECT COUNT(*) INTO current_support
  FROM Event_has_Staff EHS
  JOIN Staff S ON EHS.Staff_Staff_id = S.Staff_id
  WHERE EHS.Event_Event_id = NEW.Event_Event_id
    AND S.Role_Name = 'Support';

  IF current_support < required_support THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Insufficient support staff for this event';
  END IF;
END;
//
DELIMITER ;

DELIMITER //

CREATE TRIGGER check_support_staff_update
BEFORE UPDATE ON Event_has_Staff
FOR EACH ROW
BEGIN
  DECLARE total_audience INT;
  DECLARE required_support INT;
  DECLARE current_support INT;

  SELECT COUNT(*) INTO total_audience
  FROM Ticket
  WHERE Event_Event_id = NEW.Event_Event_id;

  SET required_support = CEIL(total_audience * 0.02);

  SELECT COUNT(*) INTO current_support
  FROM Event_has_Staff EHS
  JOIN Staff S ON EHS.Staff_Staff_id = S.Staff_id
  WHERE EHS.Event_Event_id = NEW.Event_Event_id
    AND S.Role_Name = 'Support';

  IF current_support < required_support THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Insufficient support staff for this event';
  END IF;
END;
//
DELIMITER ;


-- === unique_eancode.sql ===
ALTER TABLE Ticket
ADD CONSTRAINT unique_eancode UNIQUE (EANCode);

-- === unique_rating_per_visitor_performance.sql ===
-- Περιορισμός μοναδικότητας αξιολόγησης ανά επισκέπτη και εμφάνιση

ALTER TABLE Rating
ADD CONSTRAINT unique_visitor_performance
UNIQUE (Visitor_Visitor_id, Performance_Performance_id);

-- === unique_visitor_event.sql ===
-- Ένας επισκέπτης δεν μπορεί να έχει 2 εισιτήρια για το ίδιο event

ALTER TABLE Ticket
ADD CONSTRAINT unique_visitor_event UNIQUE (Visitor_Visitor_id, Event_Event_id);

-- === valid_equipment_quantity.sql ===
-- Περιορισμός: Quantity ≥ 0

ALTER TABLE Stage_has_Equipment
ADD CONSTRAINT chk_equipment_quantity
CHECK (Quantity >= 0);

-- === techn_max_2_performances_per_day.sql ===
-- Κάθε τεχνικός μπορεί να υποστηρίζει έως 2 εμφανίσεις την ίδια ημέρα

DELIMITER //

CREATE TRIGGER trg_Limit_Technician_Performances
BEFORE INSERT ON Event_has_Staff
FOR EACH ROW
BEGIN
  DECLARE performance_date DATE;
  DECLARE staff_role VARCHAR(45);
  DECLARE appearances_on_day INT;

  -- Βρες το ρόλο του προσωπικού
  SELECT Role_Name INTO staff_role
  FROM Staff
  WHERE Staff_id = NEW.Staff_Staff_id;

  -- Μόνο για τεχνικούς εφαρμόζεται αυτός ο περιορισμός
  IF staff_role = 'Technician' THEN

    -- Βρες την ημερομηνία του event που πάει να ανατεθεί
    SELECT Date INTO performance_date
    FROM Event
    WHERE Event_id = NEW.Event_Event_id;

    -- Μέτρα πόσες performances την ίδια μέρα υποστηρίζει ήδη
    SELECT COUNT(*) INTO appearances_on_day
    FROM Event_has_Staff es
    JOIN Event e ON es.Event_Event_id = e.Event_id
    JOIN Staff s ON es.Staff_Staff_id = s.Staff_id
    WHERE s.Role_Name = 'Technician'
      AND es.Staff_Staff_id = NEW.Staff_Staff_id
      AND e.Date = performance_date;

    -- Αν είναι ήδη 2, μπλοκάρουμε
    IF appearances_on_day >= 2 THEN
      SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'A technician cannot support more than 2 performances per day.';
    END IF;

  END IF;

END;
//

DELIMITER ;

-- === unique_festival_year.sql ===
-- Το φεστιβάλ διεξάγεται ετησίως

ALTER TABLE Festival
ADD CONSTRAINT unique_festival_year
UNIQUE (Year);


-- === consecutive_days.sql ===
-- Το φεστιβάλ διεξάγεται ετησίως, σε μία ή περισσότερες συνεχόμενες ημέρες

ALTER TABLE Festival
ADD CONSTRAINT chk_consecutive_days
CHECK (Days = DATEDIFF(EndDate, StartDate) + 1);


-- === unique_location_per_year.sql ===
-- Το φεστιβάλ διεξάγεται ετησίως, σε διαφορετική τοποθεσία ανά έτος

DELIMITER //

CREATE TRIGGER trg_Unique_Location_Per_Year
BEFORE INSERT ON Festival
FOR EACH ROW
BEGIN
  DECLARE existing_location INT;

  SELECT COUNT(*) INTO existing_location
  FROM Festival
  WHERE Year = NEW.Year AND Location_Location_id = NEW.Location_Location_id;

  IF existing_location > 0 THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'A festival cannot be held in the same location more than once per year.';
  END IF;
END;
//

DELIMITER ;

-- === stage_event_overlap.sql ===
-- Κάθε σκηνή μπορεί να φιλοξενεί μόνο μία παράσταση (event) την ίδια στιγμή

DELIMITER //

CREATE TRIGGER trg_OnlyOneEventAtTime_PerStage
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
  DECLARE stage_id INT;
  DECLARE overlap_count INT;

  -- Βρες τη σκηνή στην οποία θα γίνει η νέα εμφάνιση
  SELECT Stage_Stage_id INTO stage_id
  FROM Event
  WHERE Event_id = NEW.Event_Event_id;

  -- Έλεγξε αν υπάρχουν άλλες performances την ίδια στιγμή στη σκηνή
  SELECT COUNT(*) INTO overlap_count
  FROM Performance p
  JOIN Event e ON p.Event_Event_id = e.Event_id
  WHERE e.Stage_Stage_id = stage_id
    AND (
      -- Η νέα performance ξεκινά μέσα σε υπάρχουσα
      (NEW.StartTime BETWEEN p.StartTime AND ADDTIME(p.StartTime, SEC_TO_TIME(p.Duration * 60)))
      OR
      -- Ή υπάρχουσα ξεκινά μέσα στη νέα
      (p.StartTime BETWEEN NEW.StartTime AND ADDTIME(NEW.StartTime, SEC_TO_TIME(NEW.Duration * 60)))
    );

  IF overlap_count > 0 THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Only one event (via its performances) can be active on a stage at a time.';
  END IF;
END;
//

DELIMITER ;


-- === sequential_performances_per_event.sql ===
-- Σε κάθε event, οι performances πρέπει να είναι σειριακές

DELIMITER //

CREATE TRIGGER trg_Sequential_Performances_Per_Event
BEFORE INSERT ON Performance
FOR EACH ROW
BEGIN
  DECLARE last_end DATETIME;

  -- Βρες τη λήξη της τελευταίας performance του event (αν υπάρχει)
  SELECT MAX(ADDTIME(StartTime, SEC_TO_TIME(Duration * 60))) INTO last_end
  FROM Performance
  WHERE Event_Event_id = NEW.Event_Event_id;

  -- Αν υπάρχει προηγούμενη performance, έλεγξε αν η νέα ξεκινά ακριβώς μόλις τελειώσει
  IF last_end IS NOT NULL AND NEW.StartTime != last_end THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Performances in an event must be sequential without time gaps.';
  END IF;
END;
//

DELIMITER ;


-- === fifo_only_when_sold_out.sql ===
-- Όταν εξαντλούνται τα εισιτήρια ενεργοποιείται η ουρά fifo

DELIMITER //

CREATE TRIGGER trg_FIFO_Only_When_SoldOut
BEFORE INSERT ON Visitor_wants_Ticket
FOR EACH ROW
BEGIN
  DECLARE issued_tickets INT;
  DECLARE max_capacity INT;

  -- Βρες πόσα εισιτήρια έχουν εκδοθεί για το event
  SELECT COUNT(*) INTO issued_tickets
  FROM Ticket
  WHERE Event_Event_id = NEW.Event_id;

  -- Βρες τη μέγιστη χωρητικότητα της σκηνής
  SELECT s.MaxCapacity INTO max_capacity
  FROM Event e
  JOIN Stage s ON e.Stage_Stage_id = s.Stage_id
  WHERE e.Event_id = NEW.Event_id;

  -- Αν δεν έχει εξαντληθεί η χωρητικότητα, δεν επιτρέπεται είσοδος στην FIFO ουρά
  IF issued_tickets < max_capacity THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Tickets are still available for this event. You cannot join the FIFO queue yet.';
  END IF;
END;
//

DELIMITER ;


-- === resale_only_if_soldout.sql ===
-- Επιτρέπεται να εμφανιστεί ένας Seller_id στο Ticket μόνο όταν έχουν εξαντληθεί τα εισιτήρια του αντίστοιχου Event

DELIMITER //

CREATE TRIGGER trg_Only_Allow_Resale_When_SoldOut
BEFORE UPDATE ON Ticket
FOR EACH ROW
BEGIN
  DECLARE issued_tickets INT;
  DECLARE max_capacity INT;

  -- Αν προστίθεται seller (άρα είναι resale)
  IF NEW.Seller_id IS NOT NULL AND OLD.Seller_id IS NULL THEN

    -- Βρες πόσα εισιτήρια έχουν εκδοθεί για αυτό το event
    SELECT COUNT(*) INTO issued_tickets
    FROM Ticket
    WHERE Event_Event_id = NEW.Event_Event_id;

    -- Βρες τη μέγιστη χωρητικότητα της σκηνής
    SELECT s.MaxCapacity INTO max_capacity
    FROM Event e
    JOIN Stage s ON e.Stage_Stage_id = s.Stage_id
    WHERE e.Event_id = NEW.Event_Event_id;

    -- Αν δεν έχουν εξαντληθεί, μπλόκαρε το resale
    IF issued_tickets < max_capacity THEN
      SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'You cannot resell a ticket unless the event is sold out.';
    END IF;
  END IF;
END;
//

DELIMITER ;

-- όταν πάει να γίνει insert στη resalequeue ελέγχεται αν το θέλει κάποιος βάση event & type και δίνεται αυτόματα με fifo αλλιώς καταχωρείται

DELIMITER $$

CREATE TRIGGER before_resale_queue_insert
BEFORE INSERT ON ResaleQueue
FOR EACH ROW
BEGIN
    DECLARE v_event_id INT;
    DECLARE v_ticket_type VARCHAR(45);
    DECLARE v_current_visitor_id INT;
    DECLARE v_waiting_visitor_id INT;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_event_id = NULL;
    
    -- Get ticket details
    SELECT t.Event_Event_id, t.Ticket_Type_Type, t.Visitor_Visitor_id
    INTO v_event_id, v_ticket_type, v_current_visitor_id
    FROM Ticket t
    WHERE t.Ticket_id = NEW.Ticket_Ticket_id;
    
    -- Αν δεν βρεθεί το εισιτήριο, πετάμε σφάλμα
    IF v_event_id IS NULL THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'Ticket not found.';
    END IF;

    -- Find the earliest waiting visitor for this event and ticket type
    SELECT v.Visitor_id
    INTO v_waiting_visitor_id
    FROM Visitor_wants_Ticket v
    WHERE v.Event_id = v_event_id 
      AND v.Ticket_Type_Type = v_ticket_type
      AND v.Ticket_id IS NULL
    ORDER BY v.Timestamp ASC
    LIMIT 1;
    
    -- Αν υπάρχει κάποιος που περιμένει
    IF v_waiting_visitor_id IS NOT NULL THEN
        -- Case 1: Assign ticket to waiting visitor
        UPDATE Ticket
        SET Visitor_Visitor_id = v_waiting_visitor_id, 
            Seller_id = NULL
        WHERE Ticket_id = NEW.Ticket_Ticket_id;
        
        -- Remove all waitlist entries for this visitor/event/type
        DELETE FROM Visitor_wants_Ticket
        WHERE Visitor_id = v_waiting_visitor_id
          AND Event_id = v_event_id
          AND Ticket_Type_Type = v_ticket_type;
        
        -- Cancel the resale_queue insertion with SIGNAL
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'Ticket assigned directly to waiting visitor. Resale canceled.';
    ELSE
        -- Case 2: No one is waiting, proceed with resale queue
        -- Update the seller info
        UPDATE Ticket
        SET Seller_id = v_current_visitor_id
        WHERE Ticket_id = NEW.Ticket_Ticket_id;
        
        -- Ensure entry timestamp is set
        SET NEW.Timestamp = IFNULL(NEW.Timestamp, NOW());
    END IF;
END $$

DELIMITER ;

-- όταν πάει να γίνει insert στο visitor_wants_ticket αν θέλει συγκεκριμένο διαθέσιμο εισητήριο πωλείται, αν θέλει event&type που υπάρχει διαθέσιμο πωλείται αλλιώς καταχωρείται 

DELIMITER //
CREATE TRIGGER before_visitor_wants_ticket_insert
BEFORE INSERT ON Visitor_wants_Ticket
FOR EACH ROW
BEGIN
    DECLARE v_ticket_exists INT;
    DECLARE v_oldest_resale_ticket_id INT;
    DECLARE v_event_id INT;
    DECLARE v_ticket_type VARCHAR(50);
    
    -- Περίπτωση 1: Θέλει συγκεκριμένο εισιτήριο
    IF NEW.Ticket_id IS NOT NULL THEN
        -- Ελέγχουμε αν υπάρχει αυτό το εισιτήριο στη resale_queue
        SELECT COUNT(*) INTO v_ticket_exists
        FROM ResaleQueue
        WHERE Ticket_Ticket_id = NEW.Ticket_id;
        
        IF v_ticket_exists = 0 THEN
            -- Το εισιτήριο δεν είναι διαθέσιμο
            SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'Ticket not available in resale queue';
        ELSE
            -- Ενημέρωση εισιτηρίου - δίνουμε στον επισκέπτη
            UPDATE Ticket
            SET Visitor_Visitor_id = NEW.Visitor_id,
                Seller_id = NULL
            WHERE Ticket_id = NEW.Ticket_id;
            
            -- Διαγραφή από resale_queue
            DELETE FROM ResaleQueue
            WHERE Ticket_Ticket_id = NEW.Ticket_id;
            
            -- Ακύρωση Insert με SIGNAL
            SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'Ticket assigned directly. Insert canceled.';
        END IF;
        
    -- Περίπτωση 2: Ζητάει οποιοδήποτε εισιτήριο για event και type
    ELSE
        -- Ψάχνουμε το πιο παλιό εισιτήριο
        SELECT r.Ticket_Ticket_id INTO v_oldest_resale_ticket_id
        FROM ResaleQueue r
        JOIN Ticket t ON r.Ticket_Ticket_id = t.Ticket_id
        WHERE t.Event_Event_id = NEW.Event_id
          AND t.Ticket_Type_Type = NEW.Ticket_Type
        ORDER BY r.Timestamp ASC
        LIMIT 1;
        
        IF v_oldest_resale_ticket_id IS NOT NULL THEN
            -- Ενημέρωση εισιτηρίου
            UPDATE Ticket
            SET Visitor_Visitor_id = NEW.Visitor_id,
                Seller_id = NULL
            WHERE Ticket_id = v_oldest_resale_ticket_id;
            
            -- Διαγραφή από resale_queue
            DELETE FROM ResaleQueue
            WHERE Ticket_Ticket_id = v_oldest_resale_ticket_id;
            
            -- Ακύρωση Insert με SIGNAL
            SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'Ticket assigned directly from resale queue. Insert canceled.';
        ELSE
            -- Δεν βρέθηκε εισιτήριο, συμπληρώνουμε timestamp αν δεν υπάρχει
            SET NEW.timestamp = IFNULL(NEW.timestamp, NOW());
        END IF;
    END IF;
END//
DELIMITER ;


SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;


